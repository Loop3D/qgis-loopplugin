# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Loop_pluginDialog
                                 A QGIS plugin
 This plugin preprocess shapefile inputs to generate python script and json file that are used as input for map2loop
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-10-13
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Michel M. Nzikou / CET - UWA
        email                : michel.nzikou@alumni.uleth.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os,glob
import sys
from qgis.utils import iface
from qgis.PyQt import uic,QtWidgets
from qgis.core import QgsProject
from PyQt5.QtWidgets import  QFileDialog, QMessageBox
from PyQt5.QtCore import*
from PyQt5.QtGui import*
import subprocess
from pathlib import Path
import os.path,shutil,time
from datetime import datetime
from .load_vectors import shape_file_loader,xlayer_reader,create_json_file
from .create_python_file import save_a_python_file,find_relative_path
from .help_function import sort_layer_param
from .feature_import import qpush_desactivator,label_mover,qline_and_label_mover,qlineeditor_default_string,welcoming_image,save_activator,icon_indexer,list_all_layers,activate_loader_checkbox,activate_config_file,reset_all_features,set_to_tristate,reset_after_run
from .clear_features import clear_all_label,clear_partially_combo_list,combo_list,hide_all_combo_list,hide_dtm_feature,reset_qgis_cbox,hide_http,disabled_qgis_chkbox,retry_function
from .layer_parameter_extractor import load_data_when_qgis_is_choosen,three_push_activator
from .hover_event import show_my_info,layer_show_tooltype
from .create_your_roi import create_scratch_layer,select_your_roi_region,saving_your_roi,set_your_clip
from .feature_import import welcoming_image,list_all_layers,update_file_path
from .save_to_shp_and_geojson import create_strip_shapefile,create_geojson_file
from .run_map2loop import hide_map2loop_features,run_client
# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'loop_plugin_dialog_base.ui'))


class Loop_pluginDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(Loop_pluginDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        #
        self.setupUi(self)
        hide_all_combo_list(self,0), welcoming_image(self,1), hide_dtm_feature(self,0),hide_http(self,0)
        #
        # hide map2loop qlineeditor and label
        self.map2loop_qline_list = [self.map2loop_label_1,self.map2loop_label_2,self.map2loop_label_3,self.map2loop_Ok_pushButton]
        self.map2loop_label_list = [self.map2loop_1,self.map2loop_2,self.map2loop_3,self.map2loop_Ok_pushButton]
        hide_map2loop_features(self.map2loop_label_list,self.map2loop_qline_list,False)
     

        self.CRS_LineEditor.setText(str('epsg:28350')) 
        self.crs_value     = self.CRS_LineEditor.text()

        self.SearchFolder.setEnabled(False)
        self.params_function_activator(False) 
        activate_loader_checkbox(self,0)
        icon_indexer(self)
        '''
        Connect button
        '''
        self.FolderSearch_Button.pressed.connect(self.select_folder)
        self.GeolButton.clicked.connect(self.save_geol_param)
        self.FaultButton.clicked.connect(self.save_fault_param)
        self.StructButton.clicked.connect(self.save_struct_param)
        self.DTMButton.clicked.connect(self.save_dtm_path)
        self.Saveconfig_pushButton.clicked.connect(self.save_config_file)   
        self.ROIButton.clicked.connect(self.save_roi_layer) 
        #self.Test_Button.clicked.connect(self.run_map2loop_module) 
        #self.Test_Button.hide()
        self.Map2Loop_Button.clicked.connect(self.run_map2loop_module) 
        self.Reload_btnPush.clicked.connect(self.reset_all_pushbutton)
        #self.LoopStructural_Button.clicked.connect(self.run_loopstructural_module) 
        '''
        Enable button
        '''
        self.DTMButton.setEnabled(False)     # We flag to False to workout the first 3 layers
        self.Orientation_checkBox.setEnabled(False)
        self.ROI_checkBox.setEnabled(False)
        self.Drillhole_checkBox.setEnabled(False)
        self.Section_checkBox.setEnabled(False)
        self.Folds_checkBox.setEnabled(False)
        self.Config_checkBox.setEnabled(False)
        self.OrientationButton.setEnabled(False)
        
        self.DrillholesButton.setEnabled(False)
        self.SectionsButton.setEnabled(False)
        self.FoldButton.setEnabled(False)
        self.ConfigButton.setEnabled(False)
        self.Saveconfig_pushButton.setEnabled(False)

        layers = [tree_layer.layer() for tree_layer in QgsProject.instance().layerTreeRoot().findLayers()]
        if not layers:
            self.ROIButton.setEnabled(False)
        else:
            self.ROIButton.setEnabled(True)
        
        '''
        Inactivate  unnecessary tab
        Here we inactivate verbose1,2,3..Ongoing work
        '''
        
        self.Verbose1_radioButton.setEnabled(False)
        self.Verbose2_radioButton.setEnabled(False)
        self.Verbose3_radioButton.setEnabled(False)
        self.Overwrite_checkBox.setEnabled(False)
        self.LoopStructural_Button.setEnabled(False)
        self.Map2Loop_Button.setEnabled(False)

        self.ShapeButton.hide()
        self.GeojsonButton.hide()
        self.tableWidget.hide()
        self.PlaceHoldercomboBox.hide()
        self.PlaceHolderQlineEdit.hide()
        self.map2loop_log_TextEdit.hide()
        self.map2loop_progressBar.hide()                  ### hide progressBar
        self.Reload_btnPush.hide()                        ### Reload PushButton
        #self.CRS_LineEditor.hide()                       ### delete crs value
        #self.CRS_label.hide()                            ### hide crs label
        self.Ok_ClipLayer.hide()
        show_my_info(self)


    def run_map2loop_module(self):
        '''
        Transfert data into the remote server
        '''
        # disable map2loop and 
        self.Map2Loop_Button.setEnabled(False)
        self.LoopStructural_Button.setEnabled(False)
        # unhide map2loop qlineeditor and label
        map2loop_msg    = QMessageBox.question(self, 'Execution channel', "Where to execute map2loop? \n \n Yes:--> To the server.  \n \n No:--> To your local computer.", QMessageBox.Yes|QMessageBox.No )
        if map2loop_msg == QMessageBox.Yes:
            hide_map2loop_features(self.map2loop_label_list,self.map2loop_qline_list,True)
            self.map2loop_2.setText('Enter your name here')
            self.map2loop_1.setText('remote_machine_ip_adress_here')
            self.map2loop_3.setText(str(8000))
            self.map2loop_Ok_pushButton.clicked.connect(self.run_the_remote_service)
        else:
            QMessageBox.about(self,"Run Map2Loop on your PC ", "\n \n"+" Is your PC ready for map2loop calculatios? Update coming soon")



    def run_the_remote_service(self):
        '''
        This function run the modelling calculation on the server,
        # 1- Activate the server API
        # 2- Send the data to the server
        # 3- run map2loop and push back the result
        '''
        ##
        username           = str(self.map2loop_2.text())
        hostname           = str(self.map2loop_1.text())
        port_number        = str(self.map2loop_3.text())
        docker_config      = self.docker_config_file
        # hide the map2loop details
        hide_map2loop_features(self.map2loop_label_list,self.map2loop_qline_list,False) 
        data_folder             = str(self.first_parent_folder)#str(self.SearchFolder.text())

       # Check if websocket module exist:
        try:
            import websockets
            print('websockets is available')
        except:
            subprocess.run('pip install websockets')
            print('websockets is not available')

        run_client(self,data_folder,hostname,username,port_number,docker_config)
        return




    def save_roi_layer(self):
        '''
        Once activated, this function is used to clip layer data, multiple process are required:
        # creation of ROI via a temp scratch layer, 
        # then later, saved_clipped_layer is created from your region of interest.
        ''' 
        self.roi_status =self.sender().objectName()
        #print('roi button is {}'.format(self.sender().objectName()) )
        welcoming_image(self,2)
        self.CRS_LineEditor.hide()                       ### delete crs value
        self.CRS_label.hide()                            ### hide crs label
        # Check and disabled ROI
        self.ROI_checkBox.setChecked(True)
        self.ROIButton.setEnabled(False)
        roi_msg    = QMessageBox.question(self, 'Region of interest (ROI)', "Create your ROI? \n \n Yes:--> to create your ROI.  \n \n No:--> to load your existing ROI.", QMessageBox.Yes|QMessageBox.No )
        if roi_msg ==QMessageBox.Yes:
            create_scratch_layer(self,0)

        else:
            self.your_own_roi= True 
            self.No_flag  =True
            self.activate_layers(self.sender().text())
            self.Ok_ClipLayer.setVisible(True)
            set_your_clip(self,140, 140)
            self.Ok_ClipLayer.clicked.connect(self.save_clipped_layer)



        self.QPushbutton_functionActivator(False,self.GeolButton,self.FaultButton,self.StructButton),self.DTMButton.setEnabled(False) 
        if not QgsProject.instance().mapLayers().values() : 
        ## This section deal with loading data if qgis panel is empty
            load_msg     = QMessageBox.question(self, 'ROI Layer', "No Layer available \n \n Load now to continue?", QMessageBox.Yes|QMessageBox.No )
            self.selected_layer = []
            if load_msg==QMessageBox.Yes:
                p,self.DTMPath     = self.activate_layers(self.sender().text()) 
                continue_msg       = QMessageBox.question(self, 'ROI Layer', "Continue loading layer?", QMessageBox.Yes|QMessageBox.No )
                while continue_msg    ==QMessageBox.Yes:
                    p,self.DTMPath     = self.activate_layers(self.sender().text()) 
                    continue_msg       = QMessageBox.question(self, 'ROI Layer', "Continue loading layer?", QMessageBox.Yes|QMessageBox.No )
                    if continue_msg    ==QMessageBox.Yes:
                        continue
                    else:
                        break
        self.Ok_ClipLayer.clicked.connect(self.save_clipped_layer)
        return


    def save_clipped_layer(self):
        '''
        This code is called in save_roi_layer to create the clipped layer.
        '''
         
        self.clip_signal     = self.sender().objectName()
        # If existing ROI is loaded, run the below option
        try:
            if self.your_own_roi==True:
                layers_list      = QgsProject.instance().mapLayers().values()
                excludedIndices  = ['roi']
                layers_excl_roi  =[x for i, x in enumerate(layers_list) if x.name() not in excludedIndices]
                layer_name= []
                for layer in layers_excl_roi:
                    if type(layer).__name__ == 'QgsRasterLayer':
                        self.type_of_layer=1 
                        layer_name.append(layer.name())
                    else:
                        try:
                            if layer.name()=='temp_layer':
                                QgsProject.instance().removeMapLayers( [layer.id()] )  
                            else:
                                self.type_of_layer =layer.wkbType()
                                layer_name.append(layer.name())
                        except:
                            pass
                    select_your_roi_region(self,layer,self.type_of_layer)
                self.Ok_ClipLayer.disconnect()
                text = '\n'.join(layer_name)
                QMessageBox.about(self,"ROI Staus",str(text)+"\n \n"+"....Clipping Completed....")
            else:
                pass
        except:
              pass  

        try:
            if self.draw_your_ROI ==True:  #QMessageBox.Yes:
                layers_list      = QgsProject.instance().mapLayers().values()
                temp_layer       = [a for a in layers_list if a.name()=='temp_layer'][0]
                saving_your_roi(temp_layer,self.clip_path)
                excludedIndices  = ['roi']
                layers_excl_roi  =[x for i, x in enumerate(layers_list) if x.name() not in excludedIndices]
                
                layer_name= []
                for layer in layers_excl_roi:
                    if type(layer).__name__ == 'QgsRasterLayer':
                        self.type_of_layer=1 
                        layer_name.append(layer.name())
                    else:
                        if layer.name()=='temp_layer':
                            QgsProject.instance().removeMapLayers( [layer.id()] )  
                        else:
                            self.type_of_layer =layer.wkbType()
                            layer_name.append(layer.name())
                    select_your_roi_region(self,layer,self.type_of_layer)
                self.Ok_ClipLayer.disconnect()
                text = '\n'.join(layer_name)
                QMessageBox.about(self,"ROI Staus",str(text)+"\n \n"+"....Clipping Completed....")
            else:
                pass
        except:
            pass  
        self.All_names=[str(l)+'_clip' for l in layer_name]     
        return


    def select_folder(self):
        '''
        This function return the project folder directory, in which the json and python script will be saved.
        Here, the user will be ask to search their data directory and select its folder. 
        '''
        self.folder_name = self.sender().objectName()
        foldername       = QFileDialog.getExistingDirectory(self.FolderSearch_Button, "Select folder ","",)
        self.SearchFolder.setText(foldername)
        activate_config_file(self)
        return 
   

    def activate_layers(self,label):
        '''
        This function is used to load the data from your local PC. It is called in create_<your layer name here>_idname function
        Once the layer qpushbutton is released, the user is asked to search the data anywhere on their directory.
        '''
        label=label
        #
        try:
            shape_file_list = []
            for shape_file in QFileDialog.getOpenFileNames(self, 'Filtered file', '', 'Filtered files (*.shp *.SHP *.tif *.TIF *.gpkg)'):
                shape_file_list.append(shape_file)
            list_of_files     = shape_file_list[0]
            self.path_file    = list_of_files[0]
            self.colNames     = shape_file_loader(list_of_files)
            
        except:
            buttonReply       = QMessageBox.question(self,"Layer status", str('No Layer selected? \n\n'+ 'Load now'),QMessageBox.Yes|QMessageBox.No)
            if buttonReply    == QMessageBox.Yes:
                shape_file_list = []
                for shape_file in QFileDialog.getOpenFileNames(self, 'Filtered file', '', 'Filtered files (*.shp *.SHP *.tif *.TIF *.gpkg)'):
                    shape_file_list.append(shape_file)
                list_of_files     = shape_file_list[0]
                while not list_of_files:
                    buttonReply           = QMessageBox.question(self,"Layer status", str('No Layer selected? \n\n'+ 'Load now'),QMessageBox.Yes)
                    if buttonReply        == QMessageBox.Yes:
                        shape_file_list   = []
                        for shape_file in QFileDialog.getOpenFileNames(self, 'Filtered file', '', 'Filtered files (*.shp *.SHP *.tif *.TIF *.gpkg)'):
                            shape_file_list.append(shape_file)
                        list_of_files     = shape_file_list[0]
                    if len(list_of_files)==1:
                        break
                self.path_file    = list_of_files[0]
                self.colNames     = shape_file_loader(list_of_files)
            else:
                reset=QMessageBox.question(self,"App resetting", str('Reset now '),QMessageBox.Yes)
                if reset== QMessageBox.Yes:
                    self.reset_flag = self.sender().objectName()
                    self.colNames=[]
                    self.path_file=''
                    reset_after_run(self)
            return self.colNames,self.path_file if buttonReply== QMessageBox.Yes else self.close()
        return self.colNames,self.path_file 
   

    def create_geology_idname(self):
        '''
        Once Geology pushbutton is released, the function will return:
        # Geology IDs which are filled in combobox associated to the layer in Qt framework.
        # Then saved in the back end and added to the final data list.
        '''
        hide_all_combo_list(self,1)
        clear_partially_combo_list(self,10,1)
        if self.Structure_checkBox.checkState() == 2 or self.Fault_checkBox.checkState() ==2:
            self.my_combo_list = combo_list(self)
            for i in range(10):
                self.my_combo_list[i].setVisible(True)  
        self.PlaceHolderQlineEdit.hide()                          
        p,self.GeolPath  = self.activate_layers(self.sender().text())                                    
        if self.GeolButton.objectName()=='GeolButton':
            self.GeolPath= self.GeolPath
        geol_comboHeader = ['Formation*', 'Group','Supergroup', 'Description', 'Fm code', 'Rocktype 1','Rocktype 2','Polygon ID','Min Age','Max Age']
        label_mover(self,geol_comboHeader)
        self.colNames    = xlayer_reader(self)
        self.combo_column_appender(self.colNames,self.GeolButton.objectName())        
        qline_and_label_mover(340,200,340,220," Sill Text:",self.Sill_Label,self.Sill_LineEditor)
        qline_and_label_mover(340,280,340,300," Intrusion Text:",self.Intrusion_Label,self.Intrusion_LineEditor)
        qlineeditor_default_string(self,'sill','intrusive')
        self.params_function_activator(True)                   
        self.geolcheck = self.Geology_checkBox.checkState()
        qpush_desactivator(self,self.sender_name)
        reset_qgis_cbox(self,2)   
        self.dtm_push_activator()
        return


    def create_fault_idname(self):
        '''
        Once Fault qpushbutton is released, the function will return:
        # Fault IDs which are filled in combobox associated to the layer in Qt framework.
        # For the combobox id=4 (Dip Direction type) only ['num','alpha'] available.
        # Then saved in the back end and added to the final data list.
        '''
        clear_partially_combo_list(self,10,1)
        p,self.FaultPath       = self.activate_layers(self.sender().text())                                   
        if self.FaultButton.objectName()=='FaultButton':
            self.FaultPath     = self.FaultPath
        fault_comboHeader      = ['Default Dip', 'Dip Direction','Feature', 'Dip Direction type', 'Fdipest', 'Point ID','Dip Dir Convention']
        self.colNames          = xlayer_reader(self)
        label_mover(self,fault_comboHeader)
        self.combo_column_appender(self.colNames,self.FaultButton.objectName())                                        
        DipDirectiontype_colNames =['num','alpha']                                 
        self.cmbDescriptionLayerIDName.clear()                                    
        self.cmbDescriptionLayerIDName.addItems(DipDirectiontype_colNames) 
        DipDirectionConv_colNames =['Strike','Dip Direction'] 
        self.cmbRocktype2LayerIDName.clear() 
        self.cmbRocktype2LayerIDName.addItems(DipDirectionConv_colNames)        
        qline_and_label_mover(340,125,340,145," Fault Text:",self.Sill_Label,self.Sill_LineEditor)
        qline_and_label_mover(340,185,340,205," fdipest Text:",self.Intrusion_Label,self.Intrusion_LineEditor)
        qlineeditor_default_string(self,'Fault','shallow,steep,vertical')
        clear_partially_combo_list(self,7,1)                        
        clear_partially_combo_list(self,7,0)                                  
        self.params_function_activator(True) 
        self.faultcheck= self.Fault_checkBox.checkState() 
        qpush_desactivator(self,self.sender_name) 
        reset_qgis_cbox(self,2) 
        self.dtm_push_activator()
        return


    def create_struct_idname(self):
        '''
        Once Structure qpushbutton is released, the function will return:
        # Structure IDs which are filled in combobox associated to the layer in Qt framework.
        # For the combobox 4=Dip Direction convention* only ['Strike','Dip Direction'] available.
        # Then saved in the back end and added to the final data list.
        '''
        clear_partially_combo_list(self,10,1)
        p,self.StructPath      = self.activate_layers(self.sender().text())                                   
        if self.StructButton.objectName()=='StructButton':
            self.StructPath    =self.StructPath 
        struct_comboHeader     = ['Dip*', 'Dip Direction*','Feature*', 'Dip Dir Convention*', 'Overturned Field', 'Point ID']
        self.colNames          = xlayer_reader(self)
        label_mover(self,struct_comboHeader)
        self.combo_column_appender(self.colNames,self.StructButton.objectName())
        DipDirectionConv_colNames =['Strike','Dip Direction']                      
        self.cmbDescriptionLayerIDName.clear()                                     
        self.cmbDescriptionLayerIDName.addItems(DipDirectionConv_colNames)                                    
        qline_and_label_mover(340,125,340,145," Bedding Text:",self.Sill_Label,self.Sill_LineEditor)
        qline_and_label_mover(340,185,340,205," Overturned Text:",self.Intrusion_Label,self.Intrusion_LineEditor)
        qlineeditor_default_string(self,'Bed','overturned')
        clear_partially_combo_list(self,6,1)                        
        clear_partially_combo_list(self,6,0)               
        self.params_function_activator(True)
        self.structcheck= self.Structure_checkBox.checkState()
        qpush_desactivator(self,self.sender_name)
        reset_qgis_cbox(self,2) 
        self.dtm_push_activator()
        return
    

    def  data_updater(self):
        '''
        This function update the output of the resulting data processing from combobox and qlineeditor as well as all parameters
        '''
        try:
            if self.sender().objectName() =='FaultButton' and self.sender_name=='GeolButton' or self.sender().objectName()=='StructButton' and self.sender_name=='GeolButton' or self.sender().objectName() =='DTMButton' and self.sender_name=='GeolButton' :
            
                self.geol_data   =[]
                self.data_geol   =[]
                geol_extra_data  =[str(self.Sill_LineEditor.text()),str(self.Intrusion_LineEditor.text())]
                for i in range(10):
                    self.geol_data.append(self.my_combo_list[i].currentText())
                self.geol_data=self.geol_data+geol_extra_data 
                for i in range(len(self.list_of_params)):
                    if i==1 or i==2:   
                        if i==2:
                                self.list_of_params[i]=self.PlaceHoldercomboBox
                        self.data_geol.append(self.list_of_params[i].currentText()) 
                    
                    else:
                        self.data_geol.append(self.list_of_params[i].text())
                    self.list_of_params[i].clear()
                self.Geology_checkBox.setChecked(True)
                self.GeolButton.setEnabled(False)
                self.tableWidget.hide()

            elif self.sender().objectName()=='GeolButton' and self.sender_name=='FaultButton'  or self.sender().objectName()=='StructButton' and self.sender_name=='FaultButton' or self.sender().objectName() =='DTMButton' and self.sender_name=='FaultButton':
                self.fault_data   =[]
                self.data_fault   =[]
                fault_extra_data  =[str(self.Sill_LineEditor.text()),str(self.Intrusion_LineEditor.text())]
                for i in range(10):
                    self.fault_data.append(self.my_combo_list[i].currentText())
                self.fault_data=self.fault_data[0:7] + fault_extra_data
                for i in range(len(self.list_of_params[0:3])):
                    
                    self.data_fault.append(self.list_of_params[i].text()) 
                    self.list_of_params[i].clear()
                self.Fault_checkBox.setChecked(True)
                self.FaultButton.setEnabled(False)
                self.tableWidget.hide()

            elif self.sender().objectName()=='DTMButton' and self.sender_name=='StructButton' or self.sender().objectName()=='FaultButton' and self.sender_name=='StructButton' or self.sender().objectName()=='GeolButton' and self.sender_name=='StructButton':
                self.struct_data  =[]
                self.data_struct  =[]  
                struct_extra_data =[str(self.Sill_LineEditor.text()),str(self.Intrusion_LineEditor.text())]
                for i in range(10):
                    self.struct_data.append(self.my_combo_list[i].currentText())
                self.struct_data=self.struct_data[0:6] + struct_extra_data
                for i in range(len(self.list_of_params[0:2])):
                    self.data_struct.append(self.list_of_params[i].text())
                    self.list_of_params[i].clear() 
                self.Structure_checkBox.setChecked(True)
                self.StructButton.setEnabled(False)
                self.tableWidget.hide()
        except:
            pass
    
        return


    def QPushbutton_functionActivator(self, status, label1, label2, label3):
        '''
        This function set the state of multiple QPushbutton either False or True. 
        # Status: True or False
        # label1: qt feature which need to be set either False or True., i.e label1=self.GeolButton
        '''
        label1.setEnabled(status), label2.setEnabled(status), label3.setEnabled(status)
        
        
    def QCheckBox_functionActivator(self, status, label1, label2, label3):
        '''
        This function set the state of multiple Qcheckbox either checked or uncheck.
        # Status: True or False
        # label1: qt feature which need to be set either False or True., i.e label1=self.Geology_checkBox
        '''
        label1.setChecked(status), label2.setChecked(status), label3.setChecked(status) 
        

    def save_dtm_path(self):
        '''
        This function load the dtm layer and its save its path to final data list.
        Once DTM qpushbutton is activated, it save the DTM path and check the DTM_Qcheckbox and hide all the other Qcheckbox.
        To avoid the Qcheckbox not to respond, we set it to: 
        1- is it checkable? 
        2-setTristate to true (i.e, 2 if statement below)
        ''' 
        
        try:
            self.data_updater()
        except:
            pass

        self.sender_name=self.sender().objectName()
     
        if self.File_checkBox.isCheckable():
            self.File_checkBox.setTristate(True)

        self.PlaceHoldercomboBox.hide()
        self.PlaceHolderQlineEdit.hide()

        hide_all_combo_list(self,0), clear_all_label(self)
        self.params_function_activator(False)
        save_activator(self,1)     
        hide_dtm_feature(self,1), welcoming_image(self,2)

        self.QPushbutton_functionActivator(False,self.GeolButton,self.FaultButton,self.StructButton),self.ROIButton.setEnabled(False) 
        self.Qgis_checkBox.setChecked(False)
        self.Qgis_checkBox.setEnabled(True)
        self.Qgis_checkBox.setCheckable(True)
        reset_qgis_cbox(self,4)
        disabled_qgis_chkbox(self)
       
        self.File_checkBox.stateChanged.connect(self.select_your_dtm_method)
        self.Aus_checkBox.stateChanged.connect(self.select_your_dtm_method)
        self.Http_checkBox.stateChanged.connect(self.select_your_dtm_method)
        self.Qgis_checkBox.stateChanged.connect(self.select_your_dtm_method)
      
        return


    def save_geol_param(self):
        '''
        MAIN Geology function
        '''
        
        # Update the CRS value
        self.crs_value     = self.CRS_LineEditor.text()
        self.crs_funct_to_hide()
        three_push_activator(self,1)

        try:
            self.data_updater()
        except:
            pass
        
        self.sender_name = self.sender().objectName()
        self.geolflag    = self.sender_name
    
        layer_show_tooltype(self,self.sender_name)
        set_to_tristate(self.Http_checkBox)

        try:
            if self.retryButton[0]=='Saveconfig_pushButton' and self.sender_name=='GeolButton':
                reset_qgis_cbox(self,2)
                self.Qgis_comboBox.setEnabled(True)
                self.Ok_pushButton.setEnabled(True)
        except:
            pass

        try:
            if self.dtm =='Aus_checkBox':
                self.Qgis_comboBox.setEnabled(True)
                self.Ok_pushButton.setEnabled(True) 
        except:
            pass

        self.Aus_checkBox.setEnabled(False) 

        self.PlaceHolderQlineEdit.hide() 
     
        hide_all_combo_list(self,0),clear_all_label(self)
        self.params_function_activator(False)
        save_activator(self,1)
        hide_dtm_feature(self, 1), welcoming_image(self,2)
        reset_qgis_cbox(self,2),disabled_qgis_chkbox(self)

        self.File_checkBox.stateChanged.connect(self.select_your_geol_method)
        self.Qgis_checkBox.stateChanged.connect(self.select_your_geol_method)
        self.Http_checkBox.stateChanged.connect(self.select_your_geol_method)
        return
        

    def save_fault_param(self):
        '''      
        MAIN Fault function
        '''
        # Update the CRS value
        self.crs_value     = self.CRS_LineEditor.text()
        self.crs_funct_to_hide()

        try: 
            self.data_updater()
        except:
            pass
 

        self.sender_name = self.sender().objectName()
        self.faultflag   = self.sender_name
    
        self.PlaceHoldercomboBox.hide()
        self.PlaceHolderQlineEdit.hide()

        layer_show_tooltype(self,self.sender_name)
        set_to_tristate(self.Http_checkBox)
        try:
            if self.retryButton[0]=='Saveconfig_pushButton' and self.sender_name=='FaultButton':
                reset_qgis_cbox(self,2)
                self.Qgis_comboBox.setEnabled(True)
                self.Ok_pushButton.setEnabled(True)
        except:
            pass
        

        try:
            if self.dtm =='Aus_checkBox':
                self.Qgis_comboBox.setEnabled(True)
                self.Ok_pushButton.setEnabled(True)
        except:
            pass
        self.Aus_checkBox.setEnabled(False)  
        
        hide_all_combo_list(self,0),clear_all_label(self)
        self.params_function_activator(False)
        hide_dtm_feature(self, 1),welcoming_image(self,2)
        reset_qgis_cbox(self,2),disabled_qgis_chkbox(self)    

        self.File_checkBox.stateChanged.connect(self.select_your_fault_method)
        self.Qgis_checkBox.stateChanged.connect(self.select_your_fault_method)
        self.Http_checkBox.stateChanged.connect(self.select_your_fault_method)
        return


    def save_struct_param(self):
        '''
        MAIN Structure function
        '''
        # Update the CRS value
        self.crs_value     = self.CRS_LineEditor.text()
        self.crs_funct_to_hide()
        #three_push_activator(self,1)

        try:
            self.data_updater()
        except:
            pass
       
        self.sender_name  = self.sender().objectName()
        self.structflag   = self.sender_name
      
        self.PlaceHolderQlineEdit.hide()
        self.PlaceHoldercomboBox.hide()

        self.params_function_activator(False)
        hide_all_combo_list(self,0)
        clear_all_label(self)


        layer_show_tooltype(self,self.sender_name)
        set_to_tristate(self.Http_checkBox)
        try:
            if self.retryButton[0]=='Saveconfig_pushButton' and self.sender_name=='StructButton':
                reset_qgis_cbox(self,2)
                self.Qgis_comboBox.setEnabled(True)
                self.Ok_pushButton.setEnabled(True)
        except:
            pass
        
        try:
            if self.dtm =='Aus_checkBox':
                self.Qgis_comboBox.setEnabled(True)
                self.Ok_pushButton.setEnabled(True)
        except:
            pass

        self.Aus_checkBox.setEnabled(False)
        hide_dtm_feature(self, 1), welcoming_image(self,2)
        reset_qgis_cbox(self,2)
        disabled_qgis_chkbox(self)
        self.File_checkBox.stateChanged.connect(self.select_your_struct_method)
        self.Qgis_checkBox.stateChanged.connect(self.select_your_struct_method)
        self.Http_checkBox.stateChanged.connect(self.select_your_struct_method)
        return


    def select_your_struct_method(self):
        '''
        This function is used to populate 2 way of loading the geology layer.
        '''
        try:
            struct_flag=[]
            if self.sender().objectName()=='File_checkBox'and self.StructButton.isEnabled()==True and self.sender_name=='StructButton':
                struct_flag.append(self.sender().objectName())
                if self.File_checkBox.isChecked()== True:
                    hide_all_combo_list(self,1)
                    hide_dtm_feature(self,0)
                    self.create_struct_idname()
                    self.File_checkBox.disconnect()
            elif self.sender().objectName()=='Qgis_checkBox' and self.StructButton.isEnabled()==True and self.sender_name=='StructButton':
                struct_flag.append(self.sender().objectName())
                hide_dtm_feature(self,5)
                self.layer_dict,self.layers_object=list_all_layers(self)  
                self.Ok_pushButton.clicked.connect(self.select_your_layer_value) 
            elif self.sender().objectName()=='Http_checkBox'and self.StructButton.isEnabled()==True and self.sender_name=='StructButton':
                struct_flag.append(self.sender().objectName())
                if self.Http_checkBox.isChecked()== True:
                    hide_dtm_feature(self,4)
                    hide_http(self,1)
                    self.SaveHttp_pushButton.clicked.connect(self.select_your_http_value)
                    hide_dtm_feature(self, 0)
                    activate_config_file(self) 
                    self.Http_checkBox.setChecked(False)
            else:
                pass
            self.struct=struct_flag[0]
        except:
            pass
        return


    def select_your_fault_method(self):
        '''
        This function is used to populate 2 way of loading the fault layer.
        ''' 
        try:
            fault_flag=[]
            
            if self.sender().objectName()=='File_checkBox'and self.FaultButton.isEnabled()==True and self.sender_name=='FaultButton':
                fault_flag.append(self.sender().objectName())
                if self.File_checkBox.isChecked()== True:
                    hide_all_combo_list(self,1)
                    hide_dtm_feature(self,0)
                    self.create_fault_idname()
                    self.File_checkBox.disconnect()
            elif self.sender().objectName()=='Qgis_checkBox'and self.FaultButton.isEnabled()==True and self.sender_name=='FaultButton':
                fault_flag.append(self.sender().objectName())
                
                hide_dtm_feature(self,5)
                self.layer_dict,self.layers_object=list_all_layers(self)  
                self.Ok_pushButton.clicked.connect(self.select_your_layer_value)
            elif self.sender().objectName()=='Http_checkBox'and self.FaultButton.isEnabled()==True and self.sender_name=='FaultButton':
                fault_flag.append(self.sender().objectName())
                if self.Http_checkBox.isChecked()== True:
                    hide_dtm_feature(self,4)
                    hide_http(self,1)
                    self.SaveHttp_pushButton.clicked.connect(self.select_your_http_value)
                    hide_dtm_feature(self, 0)
                    activate_config_file(self)
                    self.Http_checkBox.setChecked(False)
            else:
                pass
            self.fault=fault_flag[0]
        except:
            pass
        return


    def select_your_geol_method(self):
        '''
        This function is used to populate 2 way of loading the geology layer.
        '''
        try:
            geol_flag=[]
            if self.sender().objectName()=='File_checkBox'and self.GeolButton.isEnabled()==True and self.sender_name=='GeolButton':
                geol_flag.append(self.sender().objectName())
                if self.File_checkBox.isChecked()== True:
                    hide_all_combo_list(self,1)
                    hide_dtm_feature(self,0)
                    self.create_geology_idname()
                    self.File_checkBox.disconnect()
            elif self.sender().objectName()=='Qgis_checkBox' and self.GeolButton.isEnabled()==True and self.sender_name=='GeolButton':
                geol_flag.append(self.sender().objectName())
                hide_all_combo_list(self,0)
                hide_dtm_feature(self,5)
                self.layer_dict,self.layers_object=list_all_layers(self)
                self.Ok_pushButton.clicked.connect(self.select_your_layer_value)  
            elif self.sender().objectName()=='Http_checkBox'and self.GeolButton.isEnabled()==True and self.sender_name=='GeolButton':
                geol_flag.append(self.sender().objectName())
                if self.Http_checkBox.isChecked()== True:
                    hide_dtm_feature(self,4)
                    hide_http(self,1)
                    self.SaveHttp_pushButton.clicked.connect(self.select_your_http_value)
                    hide_dtm_feature(self, 0)
                    activate_config_file(self)
                    self.Http_checkBox.setChecked(False)     
            else:
                pass
            self.geol=geol_flag[0]
        except:
            pass
        return


    def select_your_dtm_method(self):
        '''
        This function is used to populate 3 way of loading the dtm.
        '''
        try:
            dtm_flag=[]
            if self.sender().objectName()=='File_checkBox'and self.DTMButton.isEnabled()==True and self.sender_name=='DTMButton':
                dtm_flag.append(self.sender().objectName())
                hide_dtm_feature(self, 0)
                p,self.DTMPath     =self.activate_layers(self.sender().text()) 
                self.DTM_filename  = str(self.DTMPath)  
                hide_dtm_feature(self, 0)
                self.QPushbutton_functionActivator(True,self.GeolButton,self.FaultButton,self.StructButton),self.ROIButton.setEnabled(True) 
                self.DTM_checkBox.setChecked(True)
                activate_config_file(self)
                self.File_checkBox.disconnect()
            elif self.sender().objectName()=='Aus_checkBox'and self.DTMButton.isEnabled()==True and self.sender_name=='DTMButton':
                dtm_flag.append(self.sender().objectName())
                hide_dtm_feature(self,3) 
                self.DTM_filename  ='http://services.ga.gov.au/gis/services/DEM_SRTM_1Second_over_Bathymetry_Topography/MapServer/WCSServer?'
                hide_dtm_feature(self, 0)
                self.QPushbutton_functionActivator(True,self.GeolButton,self.FaultButton,self.StructButton),self.ROIButton.setEnabled(True) 
                self.DTM_checkBox.setChecked(True)
                activate_config_file(self)
                self.Aus_checkBox.setChecked(False)
                self.Aus_checkBox.disconnect()
            elif self.sender().objectName()=='Http_checkBox'and self.DTMButton.isEnabled()==True and self.sender_name=='DTMButton':
                dtm_flag.append(self.sender().objectName())
                hide_dtm_feature(self,4)
                hide_http(self,1)
                self.SaveHttp_pushButton.clicked.connect(self.select_your_http_value)
                hide_dtm_feature(self, 0)
                self.QPushbutton_functionActivator(True,self.GeolButton,self.FaultButton,self.StructButton),self.ROIButton.setEnabled(True) 
                activate_config_file(self)
                self.Http_checkBox.setChecked(False)
            elif self.sender().objectName()=='Qgis_checkBox'and self.DTMButton.isEnabled()==True and self.sender_name=='DTMButton': 
                dtm_flag.append(self.sender().objectName())    
                self.layer_dict,self.layers_object=list_all_layers(self)
                self.Ok_pushButton.clicked.connect(self.select_your_dtm_value)
            else:
                pass
            self.dtm=dtm_flag[0]
        except:
            pass
        return


    def crs_funct_to_hide(self):
        '''
        This function is used the CRS label and lineeditor from main qgis panel
        '''
        self.CRS_LineEditor.hide()                      
        self.CRS_label.hide()


    def dtm_push_activator(self):
        '''
        This function activate dtm qpush button if two of the other qpush_checkbox is valid
        '''
        try:
            if self.geolflag  =='GeolButton' and self.faultflag =='FaultButton' and self.structflag=='StructButton':
                self.DTMButton.setEnabled(True)           
            else:
                self.DTMButton.setEnabled(False)
        except:
            pass
    
        return 



    def select_your_dtm_value(self):
        '''
        This function return the dtm file path of a selected dtm layer from qgis panel.  
        '''
        try:
            if self.Qgis_checkBox.isChecked()==True and self.sender_name=='DTMButton' : 
                self.QPushbutton_functionActivator(False,self.GeolButton,self.FaultButton,self.StructButton)
                self.selected_dtm =self.Qgis_comboBox.currentText()
                dtm_path   =[]
                for key in self.layer_dict.keys():
                    if str(key)           == str(self.selected_dtm):
                        path              =  self.layer_dict[key]
                        dtm_path.append(path)
                        hide_dtm_feature(self, 0)
                        self.QPushbutton_functionActivator(True,self.GeolButton,self.FaultButton,self.StructButton),self.ROIButton.setEnabled(True) 
                        break
            self.DTM_filename = dtm_path[0]
            self.DTM_checkBox.setChecked(True)
            activate_config_file(self)
            retry_function(self,self.retryButton[0])
        except:
            pass
        
        return 


    def select_your_layer_value(self):
        '''
        This function return the file path of geology polygon, fault polyline and structure point layers.
        Also, it is activated to select the layer to clipped for region of interests.
        '''
        try:
            layers_list            = QgsProject.instance().mapLayers().values()
            
            try:
                self.dtm_layer     = [a for a in layers_list if type(a).__name__=='QgsRasterLayer'][0]
            except: 
                pass
            self.selected_dtm =self.Qgis_comboBox.currentText()         
            try:
                if self.sender_name=='ROIButton' or self.clip_signal=='Ok_ClipLayer':
                    hide_dtm_feature(self,0)
            except:
                hide_all_combo_list(self,1)
            layer_path             = []
            ###
            for key, key2 in  zip(self.layers_object.keys(),self.layer_dict.keys()):
                if str(key)        == str(self.selected_dtm):
                    self.dict_value=  self.layers_object[key]
                    path           =  self.layer_dict[key2]
                    layer_path.append(path)
                    try:
                        if type(self.dtm_layer).__name__=='QgsRasterLayer' and self.dtm_layer.name()==str(self.selected_dtm):
                            pass
                        else:     
                    #except:
                            colname            = [ax.name() for ax in self.dict_value.fields() ]
                            self.type_of_layer = self.dict_value.wkbType()
                            load_data_when_qgis_is_choosen(self,colname,self.sender_name,self.dict_value)
                    except:
                        pass
                    hide_dtm_feature(self,0)
                    if self.sender().objectName() =='Ok_pushButton' and self.sender_name=='GeolButton':
                        self.GeolPath             = layer_path[0] 
                        activate_config_file(self)
                    elif self.sender().objectName()=='Ok_pushButton'and self.sender_name=='FaultButton':
                        self.FaultPath             = layer_path[0] 
                        activate_config_file(self)
                    elif self.sender().objectName()=='Ok_pushButton' and self.sender_name=='StructButton':
                        self.StructPath            = layer_path[0]
                        activate_config_file(self)        
                    else:   
                        pass
        except:
            pass 
        return


    def select_your_http_value(self):
            '''
            This code defines a function "select_your_http_value" in a PyQt5 application. 
            It retrieves an user input entered from a text editor widget (Http_TextEdit), and assigns it to the variable called "DTM_filename". 
            If no input is entered, a message box pops up asking the user to enter a text. Then repete the above process to set "DTM_filename".
            which in return will calls another function called "hide_http" with an argument of 0. 
            '''
            self.DTM_filename  =self.Http_TextEdit.text()
            if not self.DTM_filename : 
                QMessageBox.question(self,"No text", str('Enter Now'),QMessageBox.Yes)
                self.DTM_filename  =self.Http_TextEdit.text()
                
            else:
                hide_http(self,0) 
                if self.sender_name == 'DTMButton' and self.sender().objectName()=='SaveHttp_pushButton' and self.DTMButton.isEnabled()==True:
                    self.QPushbutton_functionActivator(True,self.GeolButton,self.FaultButton,self.StructButton) 
                    activate_config_file(self) 
                    self.DTM_checkBox.setChecked(True)
                    self.SaveHttp_pushButton.disconnect()
                elif self.sender_name == 'GeolButton' and self.sender().objectName()=='SaveHttp_pushButton' and self.GeolButton.isEnabled()==True:
                    self.Geology_checkBox.setChecked(True)
                    self.Http_checkBox.setChecked(False)
                    self.QPushbutton_functionActivator(True,self.DTMButton,self.FaultButton,self.StructButton) 
                    self.SaveHttp_pushButton.disconnect()
                elif self.sender_name == 'FaultButton' and self.sender().objectName()=='SaveHttp_pushButton' and self.FaultButton.isEnabled()==True:
                    self.Fault_checkBox.setChecked(True)
                    self.Http_checkBox.setChecked(False)
                    self.QPushbutton_functionActivator(True,self.DTMButton,self.GeolButton,self.StructButton) 
                    self.SaveHttp_pushButton.disconnect()
                elif self.sender_name == 'StructButton' and self.sender().objectName()=='SaveHttp_pushButton' and self.StructButton.isEnabled()==True:
                    self.Structure_checkBox.setChecked(True)
                    self.Http_checkBox.setChecked(False) 
                    self.QPushbutton_functionActivator(True,self.DTMButton,self.FaultButton,self.GeolButton)
                    self.SaveHttp_pushButton.disconnect()
                else:
                    pass
                
            return QMessageBox.about(self,"Upgrade", "* Upgrade coming soon *")


    def select_data_clicked(self):
        '''
        Select your data type to be saved.
        '''
        self.ShapeButton.hide()
        self.GeojsonButton.hide()
        if self.sender().objectName()=='ShapeButton':
            #Keep all file except geojson one
            try:
                for file in self.file_to_keep:
                    if '.geojson' in str(file).lower():
                        os.remove(file)
            except:
                pass
        else:
            # Keep only geojson and tif files.
            try:
                for file in self.file_to_keep:
                    if '.geojson' in str(file) or '.tif' in str(file).lower() or '.json' in str(file).lower() :
                        pass
                    else:
                        os.remove(file) 
            except:
                pass

        try:
        
            config_message       = QMessageBox.about(self,"Configuration Status", "* Processed Data Created *")
            if config_message    ==None:
                continue_msg     = QMessageBox.question(self, 'App status', "Do you want to continue?", QMessageBox.Yes|QMessageBox.Retry|QMessageBox.No )
                if continue_msg  == QMessageBox.Yes :
                    try:
                      if self.sender().objectName()=='ShapeButton' and self.reloader=='Reload_btnPush':
                        self.Saveconfig_pushButton.disconnect()
                        self.ShapeButton.disconnect()
                      elif  self.sender().objectName()=='GeojsonButton' and self.reloader=='Reload_btnPush':
                        self.Saveconfig_pushButton.disconnect()
                        self.GeojsonButton.disconnect()
                      else:      
                        pass    
                    except:
                        pass
                    QMessageBox.about(self,"Server Execution", "* Enable map2loop and loopstructural*")
                    self.LoopStructural_Button.setEnabled(True)
                    self.Map2Loop_Button.setEnabled(True)
                    self.Saveconfig_pushButton.setEnabled(False)
                    
                elif continue_msg== QMessageBox.Retry: 
                    self.retryButton.append(self.sender().objectName())
                    QMessageBox.about(self,"Reset status", "* Reset all push button*") 
                    self.Saveconfig_pushButton.setEnabled(False)
                    reset_all_features(self)
                    self.DTMButton.setEnabled(False)
                elif continue_msg== QMessageBox.No:
                    self.close()
                else:
                    pass
            else:
                pass
        except:
                pass
        

    def reset_all_pushbutton(self):
        ''' 
        This function is called to clear and reload all features
        '''
        #
        self.reloader=self.sender().objectName()
        self.Saveconfig_pushButton.setEnabled(False)
        reset_all_features(self)
        self.DTMButton.setEnabled(False)
        self.SearchFolder.clear() 
        self.map2loop_log_TextEdit.hide()
        

    def save_config_file(self):
        '''
        Once <Create config file> is released, with all data captured, this is saved into json file and also a project file is created as a python file
        some data are coded, such as: Min deposit and fold_data.
        '''

        try:
            self.fold_data        = ['feature', 'Fold axial trace', 'type','syncline']
            self.mindeposit_data  = ['site_code', 'short_name', 'site_type_','target_com','site_commo','commodity_','infrastructure']
            self.default_data     = [ 'volc', '0','No_col','500']  
            self.Alldata          = self.geol_data+self.fault_data+self.struct_data+self.mindeposit_data+self.fold_data+self.default_data 
            geol_listKeys         = ['c','g','g2','ds','u','r1','r2','o-geol','min','max','sill','intrusive'] 
            fault_listKeys        = ['fdip','fdipdir','f','fdipdir_flag','fdipest','o','ftype','fault','fdipest_vals']  
            struct_listKeys       = ['d','dd','sf','otype','bo','gi','bedding','btype'] 
            mindeposit_lisKeys    = ['msc','msn','mst','mtc','mscm','mcom','minf']
            fold_lisKeys          = ['ff','fold','t','syn']
            default_keys          = ['volcanic','fdipnull','n','deposit_dist']  
            AllKeys               = geol_listKeys + fault_listKeys + struct_listKeys + mindeposit_lisKeys + fold_lisKeys + default_keys
            formation_data        = dict(zip(AllKeys, self.Alldata))
            #print('formation_data: ', formation_data)
            json_path             = str(self.SearchFolder.text())
            
            # list of data to strip 
            list_to_strip         = [self.geol_data,self.fault_data,self.struct_data] 
            list_of_file          = [self.GeolPath, self.FaultPath,self.StructPath]

            # check if directory exist, if not create one to save new shp and geojson files 
            parent_n                   = Path(json_path)
            self.first_parent_folder   = Path(json_path) 
            # Getting the current date and time
            self.dt_string        = datetime.now().strftime("%Y_%m_%d_%H_%M_%S")
            #
            process_source_data   = str(self.first_parent_folder)+'/process_source_data_'+str(self.dt_string)
            process_output_data   = str(self.first_parent_folder)+'/output_data_'+str(self.dt_string)
            list_new_directory    = [process_source_data,process_output_data]
            self.reset_flag       = list_new_directory
             # Check if output_data or source_data folder exist?
            for dir in list_new_directory:
                if not os.path.isdir(dir):
                    os.makedirs(dir) 
 
            # check if dtm was locally loaded, then copy it into /stripshapefile or /geojson push
            try:
              if self.sender_name == 'DTMButton' and self.dtm=='File_checkBox' or self.sender_name == 'DTMButton' and self.dtm=='Qgis_checkBox':
                  shutil.copy(self.DTM_filename, process_source_data)
            except:
                pass

            for file, field_to_keep in zip(list_of_file,list_to_strip):
                find_the_layer_name = str(file).rpartition('/') 
                filename = find_the_layer_name[2].split('.')[0] 
                # create new strip shapefile
                strip_file=create_strip_shapefile(file,field_to_keep,filename,process_source_data)
                # create the geojson file associated with the above shapefile
                create_geojson_file(strip_file,filename,process_source_data)
           
            self.file_to_keep= glob.glob(str(process_source_data)+'/*')
            QMessageBox.about(self, 'Data Creation', "Data type selection?")

            self.retryButton      =[]

            try: 

               # Select either shapefile or geojson file
                self.ShapeButton.setVisible(True)
                self.GeojsonButton.setVisible(True)
                self.ShapeButton.setGeometry(250,250,400, 25)
                self.GeojsonButton.setGeometry(250,300,400, 25)
                self.ShapeButton.clicked.connect(self.select_data_clicked)
                self.GeojsonButton.clicked.connect(self.select_data_clicked)
                
                #create json file
                create_json_file(process_source_data,formation_data)
                self.docker_config_file=self.save_your_python_file(str(process_source_data))

            except:
                Layerbutton = QMessageBox.question(self, 'OOPS Path Not Selected', "Do you want to continue?", QMessageBox.Yes | QMessageBox.No)
                if Layerbutton== QMessageBox.No:
                    self.close()
                else:
                    pass
        except:
            buttonReply = QMessageBox.question(self, 'OOPS Load all Layers', "Do you want to continue?", QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel, QMessageBox.Cancel)
        return



    def combo_column_appender(self,col_list,layerobject):
        '''
        This function append a name list into the various combobox. 
        # col_list   : The column name id list
        # layerobject: Qpush button object name  
        '''
        col_list =col_list+["NONE"]

        for id,elt2 in enumerate(combo_list(self)):
            col_list= sort_layer_param(col_list,id,layerobject)
            if not self.cmbFormationLayerIDName:
                elt2.addItems(col_list)
            else:
                elt2.addItems(col_list)  
        return
 

    def default_input(self, value,input_tag):
        '''
        This function return either empty QLineEdit string or the value typed in.
        # value     : this is the qlineeditor feature that the below str will be paste
        # input_flag: this is the value (str) to be append into the qlineeditor
        '''
        value     =value
        input_tag =input_tag
        if not value:
            self.val =str(input_tag)
        else:
            self.val =value
        return self.val


    def Layer_value_selector(self,label_ref,Sill_LineEditor,Intrusion_LineEditor,default1,default2):
        '''
        Once <Save Config File> is pushed, this function return all data snap from the Qt framework.
        Note that these data are only associated to combobox and two extra labels.
        # label_ref           : qpush button activated, i.e. geology, fault, and structure ones.
        # Sill_LineEditor     : sill lineeditor qt feature
        # Intrusion_LineEditor: intrusion lineeditor qt feature
        # default1            : str to paste into self.Sill_Lineeditor
        # default2            : str to paste into self.Intrusion_LineEditor
        '''
        data          = []           
        for i in range(10):
            self.my_combo_list=combo_list(self)
            data.append(self.my_combo_list[i].currentText())
        self.Sill_input      = Sill_LineEditor.text()
        self.Intrusion_input = Intrusion_LineEditor.text()
        self.a_sill          = self.default_input(self.Sill_input, str(default1))    
        self.a_intrusion     = self.default_input(self.Intrusion_input,str(default2)) 
        if label_ref=='GeolButton':
           self.output_data  = data+[str(self.a_sill),str(self.a_intrusion)]
        elif label_ref=='FaultButton':
            self.output_data = data[0:7]+[str(self.a_sill),str(self.a_intrusion)] 
        elif label_ref=='StructButton':
            self.output_data = data[0:6]+[str(self.a_sill),str(self.a_intrusion)] 
        else:
            pass
        return self.output_data


    def params_function_activator(self,flag):
        '''
        This function is used once the load layer QPushbutton is activated.
        It automatically populate the default parameters for any layer along with their associated label. 
        However, the geologist can replace or typed their true value.
        # flag : True to generate the params or False to hide the feature in Qt framework.
        '''
        
        self.list_of_params = [self.Geol1_LineEditor,self.Geol2_LineEditor,self.Geol3_LineEditor,
                              self.Geol4_LineEditor, self.Geol5_LineEditor,self.Geol6_LineEditor,
                              self.Geol7_LineEditor,self.Geol8_LineEditor,self.Geol9_LineEditor]
        self.list_of_labels = [self.param_label1,self.param_label2,self.param_label3,
                              self.param_label4, self.param_label5,self.param_label6,
                              self.param_label7,self.param_label8,self.param_label9]
        
        N=len(self.list_of_params)
        if flag ==False:
            for i in range(N):  
                self.list_of_params[i].hide()
                self.list_of_labels[i].hide()
        else:
            if self.GeolButton.isEnabled() ==True and self.sender_name=='GeolButton':
                self.geol_param_list=['Pluton dip', 'Pluton Form', 'Intrusion Mode', 'Max thickness', 
                'Thickness buffer','Contact Decimate','Contact Dip','Contact Orientation Decimate','Misorientation']
                values=['45','','0 or 1','10000','5000', '5','-999', '5', '30']
                for i in range(len(self.geol_param_list)): 
                    self.list_of_params[i].setVisible(True)
                    self.list_of_labels[i].setVisible(True)
                    self.list_of_labels[i].setText(str(self.geol_param_list[i])) 
                    if i==1: 
                        self.list_of_params[i].addItems(['domes','saucers','pendant'] ) 
                    elif i==2:
                       self.list_of_params[i].hide()
                       self.PlaceHoldercomboBox.setVisible(True)
                       self.PlaceHoldercomboBox.addItems(['0','1'] )                        
                    else:
                        self.list_of_labels[i].setText(str(self.geol_param_list[i])) 
                        self.list_of_params[i].setText(str(values[i]))
            elif self.FaultButton.isEnabled()==True and self.sender_name=='FaultButton':
                self.PlaceHolderQlineEdit.setVisible(True)
                self.fault_param_list =['Fault dip','Decimate', 'Min length']
                default_values   =['90','5','5000']
                for i in range(len(self.fault_param_list)): 
                    self.list_of_params[i].setVisible(True)
                    self.list_of_labels[i].setVisible(True)
                    self.list_of_labels[i].setText(str(self.fault_param_list[i]))
                    self.PlaceHoldercomboBox.hide()
                    if i==1: 
                        self.list_of_params[i] = self.PlaceHolderQlineEdit
                        self.list_of_params[i].setText(str(default_values[i]))
                    else:
                        self.list_of_params[i].setText(str(default_values[i]))
            elif self.StructButton.isEnabled()==True and self.sender_name=='StructButton':
                self.PlaceHolderQlineEdit.setVisible(True)
                self.struct_param_list =['misorientation','Decimate']
                default_values   =['30','5']
                for i in range(len(self.struct_param_list)): 
                    self.list_of_params[i].setVisible(True) 
                    self.list_of_labels[i].setVisible(True)
                    self.list_of_labels[i].setText(str(self.struct_param_list[i]))
                    self.PlaceHoldercomboBox.hide()
                    if i==1: 
                       self.list_of_params[i]= self.PlaceHolderQlineEdit
                    self.list_of_params[i].setText(str(default_values[i]))
            else:
                pass
        return


    def params_function_value_save(self,list_of_elt,flag):
        '''
        This function is used once the load layer QPushbutton is activated.
        It returns default parameters for any layer that was populated using params_function_activator function.
        # list_of_elt: the param list of features,
        # flag       : represent the Qt feature activated i.e. flag=self.FaultButton
        '''
        self.data_param =[]
        if flag=='GeolButton' and flag.isEnabled()==False: 
            for i in range(len(list_of_elt)):
                if i==1 or i==2:   
                    if i==2:
                            self.list_of_params[i]=self.PlaceHoldercomboBox
                    self.data_param.append(self.list_of_params[i].currentText())
                    #print('Here ouifho;fqu;oFLQ')    
                else:
                    self.data_param.append(self.list_of_params[i].text())
        if flag=='FaultButton' and flag.isEnabled()==False: 
            for i in range(len(list_of_elt)):
                self.data_param.append(self.list_of_params[i].text())  
        elif flag=='StructButton' and flag.isEnabled()==False:
            for i in range(len(list_of_elt)):
                self.data_param.append(self.list_of_params[i].text())     
        else:
            pass        
        return self.data_param



    def save_your_python_file(self,source_path):
        '''
        Once <Save Config File> is released, this function will create a python script with all the below parameters.
        Then, return the following confirmation msg:  python file created*
        '''
        self.filepath   = str(source_path)
        self.pyfilename     = 'Run_test'       
        try: 
            if self.roi_status=='ROIButton':
                geology_filename   = update_file_path(find_relative_path(self, self.geol,self.GeolPath),self.All_names)
                fault_filename     = update_file_path(find_relative_path(self, self.fault,self.FaultPath),self.All_names)
                structure_filename = update_file_path(find_relative_path(self, self.struct,self.StructPath),self.All_names)
                fold_filename      = update_file_path(find_relative_path(self, self.fault,self.FaultPath),self.All_names) 
                if self.dtm=='File_checkbox' or self.dtm=='Qgis_checkBox' or self.dtm=='Http_checkBox': 
                    dtm_filename   = update_file_path(find_relative_path(self,self.dtm ,self.DTM_filename),self.All_names)
                else:
                    # This is kept to GA value
                    dtm_filename=find_relative_path(self,self.dtm ,self.DTM_filename) 
                
        except:
            geology_filename  = find_relative_path(self, self.geol,self.GeolPath)
            fault_filename    = find_relative_path(self, self.fault,self.FaultPath)
            structure_filename= find_relative_path(self, self.struct,self.StructPath)
            dtm_filename      = find_relative_path(self,self.dtm ,self.DTM_filename)
            fold_filename     = find_relative_path(self, self.fault,self.FaultPath)

        metadata_filename   = '.\\'+'data.json'
        mindep_filename     = 'http://13.211.217.129:8080/geoserver/loop/wfs?service=WFS&version=1.0.0&request=GetFeature&typeName=loop:null_mindeps&bbox={BBOX_STR}&srs=EPSG:28350&outputFormat=shape-zip'
        overwrite           = 'true'
        verbose_level       = 'VerboseLevel.NONE'
        project_path        ='..\\'+"/".join(str(source_path).split('/')[-1:])
        working_projection  = str(self.crs_value)
        out_dir             = project_path
        bbox_3d             ={'minx': 520000, 'miny': 7490000, 'maxx': 550000, 'maxy': 7510000, 'base': -3200, 'top': 1200}
        run_flags           ={'aus': True, 
                            'close_dip': -999.0, 
                            'contact_decimate': int(self.data_geol[5]), 
                            'contact_dip': float(self.data_geol[6]),
                            'contact_orientation_decimate': int(self.data_geol[7]), 
                            'deposits': 'Fe,Cu,Au,NONE', 
                            'dist_buffer': 10.0, 
                            'dtb': '', 
                            'fat_step': 750.0, 
                            'fault_decimate': int(self.data_fault[1]), 
                            'fault_dip': float(self.data_fault[0]), 
                            'fold_decimate': 5, 
                            'interpolation_scheme': 'scipy_rbf', 
                            'interpolation_spacing': 500.0, 
                            'intrusion_mode': int(self.data_geol[2]), 
                            'max_thickness_allowed': float(self.data_geol[3]), 
                            'min_fault_length': float(self.data_fault[2]), 
                            'misorientation': float(self.data_struct[0]), 
                            'null_scheme': 'null_scheme', 
                            'orientation_decimate': int(self.data_struct[1]), 
                            'pluton_dip': float(self.data_geol[0]), 
                            'pluton_form': str(self.data_geol[1]), 
                            'thickness_buffer': float(self.data_geol[4]), 
                            'use_fat': False, 
                            'use_interpolations': False, 
                            'fault_orientation_clusters': 2, 
                            'fault_length_clusters': 2, 
                            'use_roi_clip': False, 
                            'roi_clip_path': ''}
        proj_crs            =str(self.crs_value) 
        clut_path           =''
        qgz_file            ='../source_data/map2loop.qgz'
        qgz_split_name      = qgz_file.split('/')[-1]
        Module_Import       = 'from map2loop.project import Project \nfrom map2loop.m2l_enums import VerboseLevel \nimport shutil\n'
        project_config      = 'proj = Project(\n''                geology_filename='+"'"+str(geology_filename)+"'"+',''\n                fault_filename='+"'"+str(fault_filename)+"'"+',\n                fold_filename='+"'"+str(fold_filename)+"'"+',\n                structure_filename='+"'"+str(structure_filename)+"'"+',\n                mindep_filename='+"'"+str(mindep_filename)+"'"+',\n                dtm_filename='+"'"+str(dtm_filename)+"'"+',\n                metadata_filename='+"'"+str(metadata_filename)+"'"+',\n                overwrite='"'"+str(overwrite)+"'"+',\n                verbose_level=VerboseLevel.NONE'+',\n                project_path='+"'"+str(project_path)+"'"+',\n                working_projection='+"'"+str(working_projection)+"'"+',\n                )'
        project_update      = '\n \nproj.update_config(\n                    out_dir='+"'"+str(out_dir)+"'"+',\n                    bbox_3d='+str(bbox_3d)+',\n                    run_flags='+str(run_flags)+',\n                    proj_crs='+"'"+ str(proj_crs)+"'"+',\n                    clut_path='+"'"+str(clut_path)+"'"+',\n                )'
        project_run         = '\n \nproj.run()\n' 
        proj_dest           = 'proj.config.project_path'
        qgz_move            = '/'+ str(qgz_split_name)
        copyqgzfile         = 'shutil.copyfile('+"'"+ str(qgz_file)+"'"+ ', '+str(proj_dest)+"+'"+ str(qgz_move)+"'"+ ')'
        save_a_python_file(self,self.filepath,self.pyfilename,Module_Import,project_config,project_update,project_run,copyqgzfile)
        if self.dtm=='AU' :
            self.docker_config_file  = {
                                "bounding_box"         : str(bbox_3d),
                                "run_flags"            : str(run_flags),
                                "project_path"         : str(project_path),
                                "working_projection"   : str(working_projection),
                                "geology_filename"     : 'server_'+str(Path(self.GeolPath).name),  
                                "structure_filename"   : 'server_'+str(Path(self.StructPath).name),
                                "fault_filename"       : 'server_'+str(Path(self.FaultPath).name),
                                "fold_filename"        : 'server_'+str(Path(self.FaultPath).name),
                                "metadata_filename"    : 'server_data.json',
                                "mindep_filename"      : str(mindep_filename),
                                "dtm_filename"         : 'AU',
                                "verbose_level"        : "VerboseLevel.NONE"
                                }
        else:
            self.docker_config_file  = {
                                "bounding_box"         : str(bbox_3d),
                                "run_flags"            : str(run_flags),
                                "project_path"         : str(project_path),
                                "working_projection"   : str(working_projection),
                                "geology_filename"     : 'server_'+str(Path(self.GeolPath).name),  
                                "structure_filename"   : 'server_'+str(Path(self.StructPath).name),
                                "fault_filename"       : 'server_'+str(Path(self.FaultPath).name),
                                "fold_filename"        : 'server_'+str(Path(self.FaultPath).name),
                                "metadata_filename"    : 'server_data.json',
                                "mindep_filename"      : str(mindep_filename),
                                "dtm_filename"         : 'server_'+str(Path(self.DTM_filename).name),
                                "verbose_level"        : "VerboseLevel.NONE"
                                }
        return self.docker_config_file

'''  
FIN
'''